spc 1               // store addr of start of outer loop
mov r1, #64         // init r1 to 0 for loop counting
ld  r2, [r1]        // load data_mem[i] into r2(LSW)
add r1, #1          // set i to i+1
ld  r3, [r1]        // load data_mem[i+1] into r3(MSW)
lsl r6, r2, #5      // r6 = p2_p1_p16_0_0000
lsr r6, r6, #6      // r6 = 0000_00_p2_p1
lsl r4, r2, #3      // r4 = p4_b1_p2_p1_p16_000
lsr r4, r4, #7      // r4 = 0000_000p4
lsl r4, r4, #2      // r4 = 0000_0_p4_00
or  r6, r4          // store p4 into r6(parity reg)
lsl r4, r3, #7      // r4 = p8_000_0000
lsr r4, r4, #4      // r4 = 0000_p8_000
or  r6, r4          // store p8 into r6(parity reg)

lsl r4, r2, #4      // r4 = b1_p2_p1_p16_0000
lsr r4, r4, #7      // r4 = 0000_000_b1
lsr r5, r2, #5      // r5 = 0000_0_b4:b2
lsl r5, r5, #1      // r5 = 0000_b4:b2_0_0000
or  r4, r5          // r4 = 0000_b4:b1
lsr r5, r3, #1      // r5 = 0_b11:b5
lsl r5, r5, #4      // r5 = b8:b5_0000
or  r4, r5          // r4 = b8:b1
lsr r5, r3, #5      // r5 = 00000_b11:b9

lsl r3, r5, #0      // r3 = 00000_b11:b9 (MSW)
lsl r2, r4, #0      // r2 - b8:b1 (LSW)

lsr r4, r2, #4      // r4 = 0000_b8:b5
lsl r5, r3, #4      // r5 = 0_b11:b9_0000
or  r5, r4          // r5 = 0_b11:b5
rxr r5              // store p8 in r5
lsr r5, r5, #3      // 0000_p8_000
mov r7, #0          // 0 out r7(nParity)
or  r7, r5          // store p8 in nParity reg

lsl r4, r3, #4      // r4 = 0_b11:b9_0000
lsr r5, r2, #7      // r5 = 0000_000_b8
lsl r5, r5, #3      // r5 = 0000_b8_000
or  r4, r5          // r4 = 0_b11:b8_000
lsr r5, r2, #4      // r5 = b4:b1_0000
lsl r5, r5, #5      // r5 = 0000_0_b4:b2
or  r4, r5          // r4 = 0_b11:b8_b4:b2
rxr r4              // r4 = 0000_000_p4
lsr r4, r4, #2      // r4 = 0000_0_p4_00
or  r7, r4          // r7 = 0000_p8_p4_00

lsr r4, r3, #2      // r4 = 0000_00_b11:b10
lsl r4, r4, #5      // r4 = 0_b11:b10_0_0000
lsl r5, r2, #1      // r5 = b7:b6_XX_XXX0
lsr r5, r5, #6      // r5 = 0000_00_b7:b6
lsl r5, r5, #3      // r5 = 000_b7_b6_000
or  r4, r5          // r4 = 0_b11:b10_b7_b6_000
lsl r5, r2, #4      // r5 = b4:b3_XX_0000
lsr r5, r5, #6      // r5 = 0000_00_b4:b3
lsl r5, r5, #1      // r5 = 0000_0_b4:b3_0
or  r4, r5          // r4 = 0_b11:b10_b7_b6_b4:b3_0
lsl r5, r2, #7      // r5 = b1_000_0000
lsr r5, r5, #7      // r5 = 0000_000_b1
or  r4, r5          // r4 = 0_b11:b10_b7_b6_b4:b3_b1
rxr r4              // r4 = 0000_000_p2
lsr r4, r4, #1      // r4 = 0000_00_p2_0
or  r7, r4          // r7 = 0000_p8_p4_p2_0

lsr r4, r3, #2      // r4 = 0000_000_b11
lsl r4, r4, #6      // r4 = 0_b11_00_0000
lsl r5, r3, #7      // r5 = b9_000_0000
lsr r5, r5, #2      // r5 = 00_b9_0_0000
or  r4, r5          // r4 = 0_b11_b9_0_0000
lsl r5, r2, #1      // r5 = b7_XXX_XXX0
lsr r5, r5, #7      // r5 = 0000_000_b7
lsl r5, r5, #4      // r5 = 000_b7_0000
or  r4, r5          // r4 = 0_b11_b9_b7_0000
lsl r5, r2, #3      // r5 = b5:b4_XX_X000
lsr r5, r5, #6      // r5 = 0000_00_b5:b4
lsl r5, r5, #2      // r5 = 0000_b5:b4_00
or  r4, r5          // r4 = 0_b11_b9_b7_b5:b4_00
lsl r5, r2, #6      // r5 = b2:b1_00_0000
lsr r5, r5, #6      // r5 = 0000_00_b2:b1
or  r4, r5          // r4 = 0_b11_b9_b7_b5:b4_b2:b1
rxr r4              // r4 = 0000_000_p1
or  r7, r4          // r7 = 0000_p8_p4_p2_p1

mov #7              // r8 = 7 (other reg for upcoming xor)
xor r6              // r6 = flipped parities
lut r6, r4, #1      // r4 = bits to flip in MSW
lut r6, r5, #0      // r5 = bits to flip in LSW
mov #4              // r8 = 4 (other reg for upcoming xor)
xor r3              // r3 = possibly corrected MSW
mov #5              // r8 = 5 (other reg for upcoming xor)
xor r2              // r2 = possibly corrected LSW
add r1, #29         // set r1 to i+30
str r2, [r1]        // store corrected LSW into data_mem[i+30]
add r1, #1          // set r1 to i+31
str r3, [r1]        // store corrected MSW into data_mem[i+31]
add r1, #-29        // set r1 to i+2
mov r2, #94         // set comparison for i
mov #1              // r8 = 1 (other reg for upcoming xor)
xor r2              // compare i to 94
je  #1




// LSW =   b8 b7 b6 b5 b4 b3  b2  b1
// MSW =   0  0  0  0  0  b11 b10 b9

/* parities and bits that affect them:
p8 = 11, 10, 9, 8, 7, 6, 5
p4 = 11, 10, 9, 8,          4, 3, 2
p2 = 11, 10,       7, 6,    4, 3,    1
p1 = 11,     9,    7,    5, 4,    2, 1
flip 11 = 1111
flip 10 = 1110
etc...
anything where only 1 parity bit (ex: 0001) is affected is not a single-bit error
*/
